<!DOCTYPE html>
<html lang='en'>
  <head>
    <meta charset='utf-8'>
    <title>W3C Editing Explainer</title>
    <script src='http://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class='remove'>
      var respecConfig = {
              specStatus:   "unofficial"
          ,   shortName:    "html-editing-explainer"
          ,   editors:      [{ name: "Robin Berjon", url: "http://berjon.com/",
                               company: "W3C", companyURL: "http://w3.org/" },
                             { name: "Ben Peters", 
                               mailto: "BenjamP@microsoft.com",
                               company: "Microsoft", 
                               companyURL: "http://www.microsoft.com" }]
          ,   wg:           "HTML Working Group"
          ,   wgURI:        "http://www.w3.org/html/wg/"
          ,   wgPublicList: "public-html"
          ,   wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/40318/status"
          ,   edDraftURI:   "http://darobin.github.com/editing-explainer/"
          ,   license:      "cc-by"
        };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document is a non-normative reference, which provides an overview of the future of Rich Text Editing on the web.
        It summarizes the normative information in related specifications in easy-to-digest prose with illustrations.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This specification is an 
        <a href='http://dev.w3.org/html5/decision-policy/html5-2014-plan.html#extension-specs'>extension
        specification</a> to HTML.
      </p>
    </section>
    <section>
      <h2>Introduction</h2>
      <p>
        <a href="http://www.w3.org/TR/html5/editing.html#attr-contenteditable">contenteditable</a> is used extensively on the web to enable users to directly edit HTML content. 
        However, it is very complex and its behavior is often largely overwritten by sites or javascript frameworks. 
        Completely overwriting it is very difficult because it requires overwriting all keyboard shortcuts that perform commands like bold and undo, 
        as well as the context menu. Further, this must be done in all supported languages. 
        A <a href="https://medium.com/medium-eng/122d8a40e480">post</a> on Medium tells one perspective of why it should be changed.
        </p><p>
        To simplify this, a new level of abstraction is described in the User Intentions Explainer specification, 
        which allows overwriting the behavior of individual user intentions.
        </p><p>
        To further simplify the work for sites and frameworks that wish to override functionality for the majority of commands, 
        the Minimal ContentEditable specification (coming soon) disables all commands by default, including text input. 
        This allows sites to easily provide their own implementations of commands as well as opt in to commands that they prefer the browser to handle,
        without having to worry about what they might have missed.
      </p>
    </section>
    <section>
      <h2>Framing the Problem</h2>
        <ul><li>ContentEditable is <b>too complex and buggy</b> to be usable as-is
        <br>While we could solve this by spec'ing contentEditable's behavior, the remaining issues here cause us to look in a new direction instead.
        </li><li>ContentEditable <b>does not easily enable the wide range of editing scenarios</b>. 
            It is high-level and not supportive of <a href="http://extensiblewebmanifesto.org/">http://extensiblewebmanifesto.org/</a>.
        </li></ul>        
    </section>
    <section>
        <h2>Use Cases</h2>
        <ul><li><b>Semantic HTML WYSIWYG editor</b> for a blogging platform. (<a href="http://lists.w3.org/Archives/Public/public-editing-tf/2014Jun/0025.html">link to mail</a>)
        <br>Info: The editor needs to able to add both semantic and visual annotation to the document as it will be published as a blog.
            Headings are to be marked up with h1. h2, etc... and each acronyms, abbreviations, and so forth are marked up with respective HTML elements.
            However, the editor also supports visual annotations such as bolding, italicizing, and enlarging text, 
            each of which will be interpreted by the editor to respective underlying semantics in HTML.
        <br>More Info: Yes, and in order to keep things consistent he may want to disallow certain types of styling. 
            A few years ago it was common to see people with Joomla sites who just pasted the text into the editor after copying it from a word processor. 
            Each blog post therefore ended up having very different styling.
        </li><li>Structured content editor with <b>whitelisted DOM elements and/or classes</b>. (<a href="http://lists.w3.org/Archives/Public/public-webapps/2014AprJun/1041.html">link to mail</a>)
        <br>We do that in Fidus Writer.  
            Part of the point is to keep the structure of the document semantically defined. 
            Users can't change font sizes of individual words, etc.
            This is because one of the main tasks of scientific journal editors who currently receive drafts in Word or Libreoffice 
            format have to undo all the manual styling the writers have added in order to get everything to look in a similar way. 
            We simply take those styling possibilities away so that we can define the entire design through one stylesheet as well as easily convert to other formats, 
            such as LaTex or an Epub, and be sure that we cover all formatting tags that were used.
        </li><li>Editor that supports <b>areas of non-editable content</b>, nested editable content, etc (see fiduswriter.org, and what CKEditor are doing with widgets.) (<a href="http://lists.w3.org/Archives/Public/public-webapps/2014AprJun/1041.html">link to mail</a>)
        <br>We also do that - for example in the case of formulas. 
            Generally the text is editable near-Wysiwyg style. 
            But when it comes to formulas, we let the user enter them in Latex format and display the result using mathjax. 
            Each formula object within the text is a noneditable island. If the user clicks on it with the mouse, he can change the formula.
        <br>Another example are figures: We want them to always be block elements and to have exactly one caption without styling. 
            They are therefore non-editable islands and if the user clicks on them he can change the figure's display and the caption text.
        </li><li>Web-based <b>code editor</b> with syntax highlighting, etc. (<a href="http://lists.w3.org/Archives/Public/public-webapps/2014AprJun/1041.html">link to mail</a>)
        </li><li>Browser based <b>"word art" generator</b> where end-user types some text and it renders in 3D along a curve and in rainbow colors on a &#060;canvas&#062;. (<a href="http://lists.w3.org/Archives/Public/public-webapps/2014AprJun/1041.html">link to mail</a>)
        </li><li><b>Track changes</b> functionality within an editor (like <a href="https://github.com/NYTimes/ice">https://github.com/NYTimes/ice</a> )
        <br>(really should be run MVC in order to keep the code somewhat readable. Currently ICE breaks whenever any of the browser makers decide to change anything about contenteditable.)
        </li><li><b>Web-based DTP application</b> (<a href="http://lists.w3.org/Archives/Public/public-editing-tf/2014Jun/0025.html">link to mail</a>)
        <br>The app can creates a document that contains pagination, columns, and a complex illustrations.
            It needs to let users edit any text that appears in the document.  
            Each editable text needs to be accessible, and styles applied to text need to be backed by the application's internal model of the document.        
        </li></ul>
    </section>
    <section>
        <h2>Goals</h2>
        <ul><li>Empower authors with the right set of baseline behavior to enable creating complex editors
        </li><li>Make it easy to implement custom behavior with appropriate APIs
        </li><li>Allow overwrite of behavior for a user intention from all actions that indicate that intention using the User Intentions guidelines
        </li><li>Empower complex editors to be accessible by enabling users to understand available behaviors with little accessibility-specific work from the framework or site
        </li></ul>
    </section>
    <section>
      <h2>Minimal default handling with <code>contenteditable="minimal"</code></h2>
        <p>
        It is a pattern in web editors that are built on top of <code>contenteditable</code> to disable some commanding functionality. 
        The reason for this is that consistency for WYSIWYG editors is very hard, and requirements vary greatly from one app to the next.
        Disabling all functionality is very difficult, however.
        </p><p>
        In order to make it easier, <code>contenteditable="minimal"</code> on an element will fire all Intention Events (Selection, Clipboard, and Command),
        but only Selection events will have a default action.
        As is always the case with Intention Events, the default action for Selection events can be cancelled with <code>preventDefault()</code>.
        The browser's typical handling of Clipboard and Command events can also be enabled per command by calling <code>document.execCommand(evt.commandName)</code>.
        </p>
        <p class=issue>What low-level APIs do we need to enable to allow sites/frameworks to build their own intention handlers effectively?</p>
        <p class=issue>Which Intention Events should have default actions in <code>contenteditable="minimal"</code>? 
        Just selection events, or other events like typing characters? 
        What about inserting newlines? Backspace/delete?</p>
        <p>
        The browser's typical handling of Clipboard and Command events can also be enabled per command by calling <code>document.execCommand(evt.commandName)</code>.
        </p>
        <p class=issue><code>execCommand</code> here will cause another Intention Event to be fired. How should we handle this?<br>
		Be careful with having events fire before the DOM is updated—at a minimum you’ll want to consider whether 
		you will allow dangerous situations like the legacy MutationEvents could cause 
		(start a change -> pre-change notification -> make another change -> pre-change notification … 
		unexpected things can happen (can be especially challenging to implement securely).<br>
		HTML5’s focus event model nicely prevents these recursions from looping. 
		Similar mitigation for the “beforeinput” event of DOM Level 3 Events: https://www.w3.org/Bugs/Public/show_bug.cgi?id=25683<br>
		From Travis Leithead
		</p>
		<p class=issue>Without default text input, the current proposal for contentEditable="minimal" is essentially just enabling cursors (drawing them, dispatching events, performing default actions).  Rather than calling the mode "minimal", which is ill-defined, why not explicitly call it what it is: "cursor-only"?  Or, have contentEditable take a list of features to turn enable: contentEditable="enable-cursors enable-CommandEvents".<br>
		Or, rather than tying this concept to contentEditable, with all the assumptions and complications that brings up, why not expose this building block as a completely separate attribute?<br>
		From Julie Parent</p>
		<p class=issue>We may not need contentEditable=minimal. The same thing can be accomplished by listening for commands and calling preventDefault on all of them.</p>
		<p class=issue>How can we integrate with rich forms and validation?<br>
		From Robin Berjon, W3C</p>
    </section>
    <section>
        <h2>Implementing Custom Behavior</h2>
        We will create new APIs as needed to make editing more extensible. Details coming soon.
    </section>
    <section>
      <h2>Acknowledgements</h2>
      <p>
        Many thanks to:
      </p>
      <p>
        Adrian Bateman,
        Michael Aufreiter,
        Oliver Buchtala,
        Ryosuke Niwa,
        Julie Parent.
      </p>
    </section>
  </body>
</html>
